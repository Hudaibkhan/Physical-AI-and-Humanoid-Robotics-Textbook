# Implementation Plan: RAG Chatbot for Digital Book Website

**Branch**: `001-rag-chatbot` | **Date**: 2025-12-09 | **Spec**: [specs/001-rag-chatbot/spec.md](specs/001-rag-chatbot/spec.md)
**Input**: Feature specification from `/specs/001-rag-chatbot/spec.md`

**Note**: This template is filled in by the `/sp.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Implementation of a Retrieval-Augmented Generation (RAG) chatbot for a digital book website that allows users to ask questions about book content and receive answers generated by Google Gemini LLM based on the book material. The system includes a FastAPI backend with Qdrant vector storage, a frontend widget for Docusaurus integration, and supports text highlighting for context-specific answers.

## Technical Context

**Language/Version**: Python 3.11 (backend), JavaScript/ES6 (frontend), Markdown format for book content
**Primary Dependencies**: FastAPI, qdrant-client, google-generativeai, Pydantic, Docusaurus v3
**Storage**: Qdrant Cloud Free Tier (vector database for embeddings), potential local storage for configuration
**Testing**: pytest (backend), Jest (frontend - if applicable)
**Target Platform**: Web application (cloud deployment with Render/Vercel)
**Project Type**: Web (separate backend and frontend applications)
**Performance Goals**: <5 second response time for RAG queries, support 50 concurrent users
**Constraints**: Must use free tier services (Qdrant, Render), Gemini API usage limits, must reject out-of-book questions
**Scale/Scope**: 50 concurrent users, book content size dependent on Qdrant free tier limits

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Based on the project constitution:
1. **Spec-Driven Writing**: ✅ Plan follows specification from spec.md
2. **Technical Reliability**: ✅ Technology stack (FastAPI, Qdrant, Gemini) is established and verifiable
3. **Beginner-Friendly + Professional Tone**: ✅ Plan includes clear documentation and structured approach
4. **Documentation Quality**: ✅ Following high-quality documentation standards
5. **Consistency**: ✅ Plan maintains consistent structure with other project artifacts

## Project Structure

### Documentation (this feature)

```text
specs/001-rag-chatbot/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (/sp.plan command)
├── data-model.md        # Phase 1 output (/sp.plan command)
├── quickstart.md        # Phase 1 output (/sp.plan command)
├── contracts/           # Phase 1 output (/sp.plan command)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
backend/
├── src/
│   ├── models/
│   │   ├── embedding.py
│   │   ├── rag.py
│   │   └── chat.py
│   ├── services/
│   │   ├── embedding_service.py
│   │   ├── qdrant_service.py
│   │   ├── gemini_service.py
│   │   └── rag_service.py
│   ├── api/
│   │   ├── v1/
│   │   │   ├── router.py
│   │   │   ├── endpoints/
│   │   │   │   ├── embed.py
│   │   │   │   ├── search.py
│   │   │   │   └── ask_agent.py
│   │   │   └── schemas/
│   │   │       ├── embedding.py
│   │   │       ├── search.py
│   │   │       └── chat.py
│   ├── config/
│   │   └── settings.py
│   └── main.py
├── scripts/
│   └── upload_chunks.py
├── tests/
│   ├── unit/
│   ├── integration/
│   └── contract/
├── requirements.txt
└── Dockerfile

frontend/
├── src/
│   ├── components/
│   │   ├── ChatWidget.jsx
│   │   ├── ChatModal.jsx
│   │   ├── Message.jsx
│   │   └── InputArea.jsx
│   ├── services/
│   │   └── api.js
│   ├── styles/
│   │   └── chatbot.css
│   └── utils/
│       └── textSelection.js
├── index.html
├── package.json
└── widget.js

book/
├── docs/
│   └── [existing book content]
├── docusaurus.config.js
└── static/
    └── js/
        └── chatbot-widget.js
```

**Structure Decision**: The project will be structured as a web application with separate backend and frontend components. The backend will be a FastAPI application deployed to Render, while the frontend will be a JavaScript widget integrated into the existing Docusaurus book website deployed on Vercel. This separation allows for independent scaling and maintenance of each component.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| Multiple services architecture | Required for proper separation of concerns between frontend, backend, and vector database | Single service would create tight coupling and deployment complexity |
| Third-party dependencies (Qdrant, Gemini) | Essential for RAG functionality and LLM capabilities | Building in-house alternatives would require significant development time and resources |
